= Number theory

== Modular arithmetic

#raw(read("/code/number-theory/Mod.h"), lang: "cpp")

#raw(read("/code/number-theory/BinaryExponentiation.h"), lang: "cpp")

// #raw(read("/code/number-theory/ModLog.h"), lang: "cpp")

// #raw(read("/code/number-theory/ModSum.h"), lang: "cpp")

// #raw(read("/code/number-theory/ModMulLL.h"), lang: "cpp")

// #raw(read("/code/number-theory/ModSqrt.h"), lang: "cpp")

== Primality

#raw(read("/code/number-theory/Sieve.h"), lang: "cpp")

// #raw(read("/code/number-theory/MillerRabin.h"), lang: "cpp")

// #raw(read("/code/number-theory/Factor.h"), lang: "cpp")

== Divisibility

#raw(read("/code/number-theory/Euclid.h"), lang: "cpp")

// #raw(read("/code/number-theory/CRT.h"), lang: "cpp")

=== Bézout's identity
For $a eq.not 0$, $b eq.not 0$, let $d = gcd(a, b)$ be the smallest positive integer for which there are integer solutions to

$ a x + b y = d $

If $(x, y)$ is one solution, then all solutions are given by

$ (x + (k b)/gcd(a, b), y - (k a)/gcd(a, b)), k in ZZ $

#raw(read("/code/number-theory/Totient.h"), lang: "cpp")

== Fractions
#raw(read("/code/number-theory/Fraction.h"), lang: "cpp")
// #raw(read("/code/number-theory/ContinuedFractions.h"), lang: "cpp")
// #raw(read("/code/number-theory/FracBinarySearch.h"), lang: "cpp")

== Pythagorean Triples
The Pythagorean triples are uniquely generated by

$ a = k (m^2 - n^2), b = k (2 m n), c = k (m^2 + n^2), $

with $m > n > 0$, $k > 0$, $m perp n$, and either $m$ or $n$ even.

== Primes
$p = 962592769$ is such that $2^21 divides (p - 1)$, which may be useful. For hashing use $970592641$ (31-bit number), $31443539979727$ (45-bit), $3006703054056749$ (52-bit). There are $78498$ primes less than $1 000 000$.

Primitive roots exist modulo any prime power $p^a$, except for $p = 2$, $a > 2$, and there are $phi(phi(p^a))$ many. For $p = 2$, $a > 2$, the group $\,ZZ_(2^a)^(times)$ is instead isomorphic to $ZZ_2 times ZZ_(2^(a-2))$.

== Number / Sum / Product of Divisors
If the prime factorization of $n$ is $p_1^e_1 times p_2^e_2 times dots.h.c times p_k^e_k$, where $p_i$ are distinct prime numbers, then:

- Number of divisors: $d(n) = (e_1 + 1) (e_2 + 1) dots.h.c (e_k + 1)$
- Sum of divisors: $sigma(n) = (p_1^(e_1 + 1) - 1)/(p_1 - 1) times (p_2^(e_2 + 1) - 1)/(p_2 - 1) times dots.h.c times (p_k^(e_k + 1) - 1)/(p_k - 1)$
- Product of divisors: $n^(d(n)/2)$

#raw(read("/code/number-theory/NumberSumProductofDivisors.h"), lang: "cpp")

== Gray Code
#raw(read("/code/number-theory/GrayCode.h"), lang: "cpp")

== Fibonacci
#raw(read("/code/number-theory/Fibonacci.h"), lang: "cpp")

== Estimates
$sum_(d | n) d = O(n log log n)$.

The upper bound on the number of divisors is $n^(1/3)$. The number of divisors of $n$ is at most around $100$ for $n < 5 times 10^4$, $500$ for $n < 10^7$, $1344$ for $n < 10^9$, $2000$ for $n < 10^10$, $200,000$ for $n < 10^19$.

== Möbius Function

$ mu(n) = cases(
  0 & "n is not square free",
  1 & "n has even number of prime factors",
 -1 & "n has odd number of prime factors",
) $

Möbius Inversion:

$ g(n) = sum_(d | n) f(d) <=> f(n) = sum_(d | n) mu(d) g(n / d) $

Other useful formulas/forms:

$ sum_(d | n) mu(d) = [n = 1]$ (very useful)

$ g(n) = sum_(n | d) f(d) <=> f(n) = sum_(n | d) mu(d / n) g(d) $

$ g(n) = sum_(1 <= m <= n) f(floor(n / m)) <=> f(n) = sum_(1 <= m <= n) mu(m) g(floor(n / m)) $

#raw(read("/code/number-theory/Mobius.h"), lang: "cpp")
